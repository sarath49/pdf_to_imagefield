<?php

/**
 * @file
 *   Extends file fields with a process that generates a thumbnail image
 *   or multiple image pages from an uploaded PDF
 */

/**
 * Announces that we have additional widget options that extend file fields.
 *
 * @see file_field_widget_info()
 *
 * Implements hook_field_widget_info().
 */
function pdf_to_image_field_widget_info() {
  return array(
    'pdf_to_image' => array(
      'label'       => t('PDF to Image'),
      'field types' => array('file'),
      'settings'    => array(
        'pdf_to_image' => array(
          'target_field'        => NULL,
          'density'             => '25x25',
          'extra_args'          => '',
        ),
      ),
      'behaviors'   => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_NONE,
      ),
    ),
  );
}


/**
 * Adds options to the field configuration form in the content type admin setup.
 *
 * Implements hook_field_widget_settings_form().
 */
function pdf_to_image_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $pdf_to_image_settings = $widget['settings']['pdf_to_image'];

  // Use the file widget settings form.
  $form = file_field_widget_settings_form($field, $instance);

  // Plus our own extras
  $form['pdf_to_image'] = array(
    '#type' => 'fieldset',
    '#title' => t('PDF conversion options'),
  );

  $fields = field_info_instances($instance['entity_type'], $instance['bundle']);
  $options = array();
  foreach ((array) $fields as $field) {
    if ($field['widget']['type'] == 'image_image') {
      $options[$field['field_name']] = $field['label'];
    }
  }

  // @TODO: make this field required.
  $form['pdf_to_image']['target_field'] = array(
    '#title'         => t('Target Image Field'),
    '#type'          => 'select',
    '#empty_option'  => '<' . (count($options) ? t('No Image Field selected') : t('No Image Field found')) . '>',
    '#default_value' => $pdf_to_image_settings['target_field'],
    '#description'   => t('PDF to Image field processing requires an image field where the resulting images of extracted PDF pages should be stored. The image field must be assigned to the same node type. For all pages to be processed, the image field should allow multiple uploads. If the image field allows only one item, only the cover page will be processed.'),
    '#options'       => $options,
  );

  $form['pdf_to_image']['density'] = array(
    '#title'            => t('Density used for rendering PDF'),
    '#description'      => t('Horizontal and vertical density of the image XxY (e.g. 100x100). Default is 25x25 (25%). <em>This is not image dimensions!</em> It\'s the sampling quality of the generated image. 100x100 means the generated image will be "full size" compared to a PDF viewed at 100%. If you are only wanting preview thumbnails, you might be fine (and a LOT faster) with just 20x20 (20% size) images. Only generate full-size (100x100) images if you intend to display full-size pages. To adjust the <b>display</b> sizes on the web page, manage the display of the image field as usual.'),
    '#type'             => 'textfield',
    '#default_value'    => $pdf_to_image_settings['density'],
    '#element_validate' => array('pdf_to_image_validate_density'),
    '#size'             => 15,
    '#maxlength'        => 10,
  );

  $form['pdf_to_image']['extra_args'] = array(
    '#title'         => t('Extra conversion arguments'),
    '#type'          => 'textfield',
    '#description'   => t('Enter optional <a href="http://imagemagick.org/Usage/formats/#ps">additional parameters to be used by the imagemagick conversion</a> if needed.<br/>eg <code>-trim +repage</code>'),
    '#default_value' => !empty($pdf_to_image_settings['extra_args']) ? $pdf_to_image_settings['extra_args'] : '',
    '#size'          => 20,
  );

  // @TODO: implement this.
  $form['pdf_to_image']['extra_args']['#description'] .= '<br />' . t('WARNING! not working feature now.');

  $form['pdf_to_image']['hide_imagefield'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Hide target image field on edit form'),
    '#default_value' => !empty($pdf_to_image_settings['hide_imagefield']),
    '#description'   => t('If rendering the preview image in place of the uploaded file, you may want to hide the image field from the edit form entirely to prevent editors from adding their own.'),
  );

  // @TODO: add radiobuttons to choose way of pages generating,
  // means batch (be default now) or queue or runtime,
  // and implements this ways.
  return $form;
}


/**
 * Validate string for density settings.
 */
function pdf_to_image_validate_density($element, &$form_state) {
  $value = $element['#value'];
  if (!empty($value) && !preg_match('/^[0-9]+x[0-9]+$/', $value)) {
    form_set_error('density', t('Please specify a density in the format XxY (e.g. 100x100).'));
  }
}



/**
 * Adds another method for displaying PDF files - embedded live preview.
 *
 * Implements hook_field_formatter_info().
 */
function pdf_to_image_field_formatter_info() {
  $formatters = array(
    'pdf_view' => array(
      'label'       => t('PDF preview'),
      'field types' => array('file'),
      'settings'    => array(
        'pdf_width'  => '100%',
        'pdf_height' => '450',
      ),
    ),
  );
  return $formatters;
}


/**
 * Implements hook_field_formatter_settings_summary().
 */
function pdf_to_image_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display  = $instance['display'][$view_mode];
  $settings = $display['settings'];
  if ($display['type'] == 'pdf_view') {
    $summary  = t('Region of @width to @height, and text at download link - "@alt"', array(
      '@width'  => $settings['pdf_width'],
      '@height' => $settings['pdf_height'],
      '@alt'    => $settings['pdf_alt'],
    ));
    return $summary;
  }
}


/**
 * Implements hook_field_formatter_view().
 */
function pdf_to_image_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  if (!isset($items[0])) {
    return;
  }

  // @TOFO fix public / private handlers, apply stream wrappers functions.
  global $base_url;
  $path     = $base_url . '/' . variable_get('file_public_path') . substr($items[0]['uri'], 8);

  if ($display['type'] == 'pdf_view') {
    $width    = $display['settings']['pdf_width'];
    $height   = $display['settings']['pdf_height'];
    $alt      = $display['settings']['pdf_alt'];
    $object   = '<object width="' . $width . '" height="' . $height . '" type="application/pdf" data="' . $path . '"><a href="' . $path . '">' . $alt . '</a></object>';
  }

  if ($display['type'] == 'pdf_link') {
    // @TODO add title support.
    $object = l(t('Download file'), $path);
  }

  $element  = array();
  $element[0]['#markup'] = $object;

  return $element;
}


/**
 * Implements hook_form_alter().
 *
 * Hides the target image field from editors, if you don't want them to provide
 * their own snapshot.
 *
 * Should be able to run on any fielded entity type edit form, not just nodes.
 */
function pdf_to_image_form_alter(&$form, &$form_state, $form_id) {
  if (!isset($form['#entity_type']) || !isset($form['#bundle'])) {
    return;
  }

  // Find if this entity has any fields that use the pdf_to_image widget.
  $fields = field_info_instances($form['#entity_type'], $form['#bundle']);
  $fields_pdf = array();
  foreach ((array) $fields as $field) {
    if ($field['widget']['type'] == 'pdf_to_image') {
      $fields_pdf[$field['field_name']] = $field;
    }
  }
  if (count($fields_pdf)) {
    foreach ($fields_pdf as $field) {
      if ($field['widget']['settings']['pdf_to_image']['hide_imagefield']) {
        $target_field = $field['widget']['settings']['pdf_to_image']['target_field'];
        if (isset($form[$target_field])) {
          $form[$target_field]['#access'] = FALSE;
        }
      }
    }
  }
}


/**
 * Adds extra options to file upload widget.
 *
 * It's basically a stub around file_field_widget_form().
 *
 * Implements hook_field_widget_form().
 */
function pdf_to_image_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {

  // This is a file widget, plus extra options.
  $elements = file_field_widget_form($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);
  $settings = $instance['settings'];

  foreach (element_children($elements) as $delta) {
    // If not using custom extension validation, ensure this is a pdf.
    $elements[$delta]['#upload_validators']['file_validate_extensions'][0] = 'pdf';
    // File fields need extra processing. Our one even more so.
    #$elements[$delta]['#process'][] = 'pdf_to_image_field_widget_process';
  }
  $elements[0]['#description'] .= '<br/>' . t('This file will produce an image thumbnail and store it in %target_field when uploaded', array('%target_field' => $instance['widget']['settings']['pdf_to_image']['target_field']));

  // When a file field is being submitted, the actual save of the file happens
  // in file_managed_file_value -> file_managed_file_save_upload etc.
  // We rely on the actual upload ans save to have happened there.
  // We want to add a process that happens after that.
  // It's too deep to capture that process, so wait until it's done,
  // and then do our thing.
  // We therefore run our process as part of the form submit.
  // This should mean the element upload has already finished.
  $form['#submit'][] = 'pdf_to_image_form_submit';
  // Need to make a note on the form of what it is to process, as it will forget otherwise
  $form['#pdf_to_image'][] = $instance['field_name'];
  // pdf_to_image_form_submit() will pick this note up and use it later.

  return $elements;
}


/**
 * A field widget process callback, triggered when a form containing our widget type
 * of file is geting rendered.
 *
 * @see file_field_widget_process.
 */
function pdf_to_image_field_widget_process($element, &$form_state, $form) {
  /*
  $item = $element['#value'];
  $item['fid'] = $element['fid']['#value'];

  $field = field_widget_field($element, $form_state);
  $instance = field_widget_instance($element, $form_state);
  $settings = $instance['widget']['settings'];

  dpm('could show a thumbnail here');
  */
  return $element;
}


/**
 * Process our extra actions when a form containing a special file field has
 * been submitted.
 * This is the first step where generation really starts happening.
 *
 * @param array $form
 * @param array $form_state
 */
function pdf_to_image_form_submit($form, &$form_state) {
  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  // The field widget should have made a note of the field we need to process
  // in the custom $form['#pdf_to_image'] parameter.
  foreach ($form['#pdf_to_image'] as $field_id) {
    $instance = field_info_instance($entity_type, $field_id, $bundle);
    $items = $form_state['values'][$field_id];
    pdf_to_image_generate_process($entity_type, $form['#entity'], $field_id, $instance, $items);
  }
}

/**
 * Processing pdf file creation.
 *
 * This sets up the batch job with all the neccessary parameters
 */
function pdf_to_image_generate_process($entity_type, $entity, $field_id, $instance, &$items) {
  $field = field_info_field($field_id);
  $field_lang = field_language($entity_type, $entity, $field_id);

  if (empty($items[$field_lang][0]['fid'])) {
    // No file attachment found in the source field.
    // Do nothing.
    return;
  }
  $pdf_file = file_load($items[$field_lang][0]['fid']);
  $pdf_realpath = file_stream_wrapper_get_instance_by_uri($pdf_file->uri)->realpath();
  $count = pdf_to_image_count_pages($pdf_realpath);
  if (!empty($instance['widget']['settings']['pdf_to_image']['target_field'])) {
    $target_field = $instance['widget']['settings']['pdf_to_image']['target_field'];
  }
  // Should I check if the target field is already populated and stop then?

  if ($target_field && $count) {
    // Arguments to give to the batch job.
    $params = array(
      'entity' => $entity,
      'image'  => array(
        'field'    => field_info_field($target_field),
        'instance' => field_info_instance($entity_type, $target_field, $instance['bundle']),
      ),
      'pdf'    => array(
        'field'    => $field,
        'instance' => $instance,
        'file'     => $pdf_file,
      ),
    );

    // Prepare count parameter.
    if ($params['image']['field']['cardinality'] != -1 && $count > $params['image']['field']['cardinality']) {
      $count = $params['image']['field']['cardinality'];
    }
    $operations = array(
      array('pdf_to_image_generate_process_page', array($params, 0)),
    );

    watchdog('pdf_to_image', 'Starting a process to convert attached PDF %file to image previews', array('%file' => $params['pdf']['file']->uri), WATCHDOG_INFO);
    for ($page = 1; $page < $count; $page++) {
      $operations[] = array('pdf_to_image_generate_process_page', array($params, $page));
    }
    batch_set(array(
      'title'            => t('Converting PDF, %count pages', array('%count' => $count)),
      'operations'       => $operations,
      'finished'         => 'pdf_to_image_generate_process_attach',
      'progress_message' => t('Processed @current out of @total.'),
    ));
    // @TODO: save node with one entity without batch.
    // else {
    // $file = pdf_to_image_generate_page($params, 0);
    // }
  }
  else {
    // No target image field set, or invalid count from the PDF.
  }
}


/**
 * Generate a single page (of the given index) inside a batch process.
 *
 * A batch task, no return.
 */
function pdf_to_image_generate_process_page($params, $page_number, &$context) {
  $context['results']['params'] = $params;
  if (!isset($context['results']['files'])) {
    $context['results']['files'] = array();
  }
  $file = pdf_to_image_generate_page($params, $page_number);
  if (is_object($file) && isset($file->fid)) {
    $context['results']['files'][$page_number] = $file;
  }
}


/**
 * Generate a single page for the given pdf file.
 */
function pdf_to_image_generate_page($params, $page_number = 0) {
  $source_file = file_stream_wrapper_get_instance_by_uri($params['pdf']['file']->uri)->realpath();
  if (!file_exists($source_file)) {
    watchdog('pdf_to_image', 'Invalid file given to convert. Could not read %file', array('%file' => $params['pdf']['file']->uri), WATCHDOG_ERROR);
    return NULL;
  }

  $density = "-density " . $params['pdf']['instance']['widget']['settings']['pdf_to_image']['density'];

  $image_dir = file_stream_wrapper_get_instance_by_scheme($params['image']['field']['settings']['uri_scheme'])->realpath();
  $image_filename = $params['image']['instance']['settings']['file_directory'] . '/' . $params['pdf']['file']->fid . "-" . $page_number . '.jpg';
  $image_realpath = $image_dir . '/' . $image_filename;
  $image_uri = file_stream_wrapper_uri_normalize($params['image']['field']['settings']['uri_scheme'] . '://' . $image_filename);

  if (empty($image_uri)) {
    watchdog('pdf_to_image', 'Failed to calculate a destination filename for conversion', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  // Check to see if the target image file already exists, is registered in the
  // database. Why?
  $query = db_select('file_managed', 'f')
    ->fields('f', array('fid'))
    ->condition('uri', $image_uri)
    ->execute()->fetchCol();
  if (!empty($query)) {
    $file = file_load(array_shift($query));
    watchdog('pdf_to_image', 'PDF preview %image already exists', array('%image' => $image_uri), WATCHDOG_INFO);
    return $file;
  }

  watchdog('pdf_to_image', 'Converting PDF: %file page %page_number: to image: %image', array(
      '%file' => $params['pdf']['file']->uri,
      '%page_number' => $page_number,
      '%image' => $image_uri,
    ), WATCHDOG_INFO
  );

  pdf_to_image_convert_exec($source_file . '[' . $page_number . ']', $image_realpath, array(), array($density));

  if (file_exists($image_realpath)) {
    watchdog('pdf_to_image', 'PDF preview %image created', array(
        '%image' => $image_uri,
      ), WATCHDOG_INFO
    );

    global $user;
    $file = (object) array(
      'uid'       => $user->uid,
      'filename'  => basename($image_uri),
      'uri'       => $image_uri,
      'filemime'  => file_get_mimetype($image_uri),
      'filesize'  => @filesize($image_uri),
      'timestamp' => REQUEST_TIME,
      'status'    => FALSE,
      'is_new'    => TRUE,
    );
    file_save($file);
    return $file;
  }
  watchdog('pdf_to_image', 'Failed to generate image', array(), WATCHDOG_ERROR);
  return FALSE;
}


/**
 * Attach generated files to node at the end of batch mode.
 */
function pdf_to_image_generate_process_attach($success, $results, $operations) {
  if (!(isset($results['files']) && count($results['files']))) {
    watchdog('pdf_to_image', 'No files produced from processing document', array(), WATCHDOG_NOTICE);
    return;
  }

  $field_name = $results['params']['image']['field']['field_name'];
  $nid = $results['params']['entity']->nid;

  if (isset($nid) && is_numeric($nid)) {
    $node = node_load($nid);
    if (is_object($node)) {
      $field_lang = field_language('node', $node, $field_name);
      // This removes the existing images by emptying the list.
      // The (re?) attaches the generated ones.
      $node->{$field_name}[$field_lang] = array();
      ksort($results['files'], SORT_NUMERIC);
      foreach ($results['files'] as $file) {
        $node->{$field_name}[$field_lang][]['fid'] = $file->fid;
      }
      watchdog('pdf_to_image', 'Attached converted images to node.', array(), WATCHDOG_INFO);
      node_save($node);
    }
    else {
      watchdog('pdf_to_image', 'Invalid node object. Cannot attache generated images to it.', array(), WATCHDOG_ERROR);
    }
  }
  else {
    watchdog('pdf_to_image', 'Invalid node id given to attach generated images to.', array(), WATCHDOG_ERROR);
  }
}



/**
 * Use imagemagick routine to count the number of pages in a given PDF
 */
function pdf_to_image_count_pages($filepath) {
  // Assume the 'identify' binary lives next to the 'convert' binary.
  $convert_path  = variable_get('imagemagick_convert', '/usr/bin/convert');
  $identify_path = dirname($convert_path) . '/identify';

  // Identify renders every page in the pdf to count the number of pages which
  // can be a problem (server timeout) when processing a pdf with many pages.
  // The better command commented because it working very slow.
  // "{$identify_path} -format %n " . escapeshellarg($fpath) . ' 2> /dev/null';
  // This one instead asks for more pages than the document has, then reads the
  // error message that tells us what the last page number was instead :-}
  $command = "{$identify_path} " . escapeshellarg($filepath) . '[9999] | grep "Requested FirstPage" | cut -d : -f2';

  $count = pdf_to_image_shell_exec($command);
  return (int) trim($count);
}

/**
 * Check the binary path on the server.
 *
 * Returns NULL if it failed, the version info of imageMagick if it succeeds.
 */
function pdf_to_image_check_imagemagick() {
  $convert_path  = variable_get('imagemagick_convert', '/usr/bin/convert');
  $response = pdf_to_image_shell_exec($convert_path . ' -version');
  return $response;
}


/**
 * FWIW, may not need imagemagick module, just for this one func.
 * If you want debugging and Win32 support, use imagemagick.module.
 * Otherwise, here's a short and dirty version of the same thing.
 *
 */
function pdf_to_image_convert_exec($source, $dest, $args = array(), $extra = array()) {
  $args['quality'] = '-quality ' . escapeshellarg(variable_get('imagemagick_quality', 75));
  $command = implode(' ', $extra) . ' ' . escapeshellarg($source) . ' ' . implode(' ', $args) . ' ' . escapeshellarg($dest);

  if (function_exists('x_imagemagick_convert_exec')) {
    if (_imagemagick_convert_exec($command, $output, $errors) !== TRUE) {
      $errors_txt = '<pre>' . (is_array($errors) ? implode("\n", $errors) : $errors) . '</pre>';
      watchdog('pdf to image : imageapi imagemagick', $errors_txt, array(), WATCHDOG_ERROR);
      return FALSE;
    }
    return file_exists($dest);
  }

  // else do it myself

  $convert_path  = variable_get('imagemagick_convert', '/usr/bin/convert');
  $response = pdf_to_image_shell_exec($convert_path . ' ' . $command);
  return file_exists($dest);
}

/**
 * Run the given command (expected to be an imageMagick Commandline)
 * Wrapped in a bugfix workaround.
 *
 * @param string $command
 */
function pdf_to_image_shell_exec($command) {
  // Horrible bug. If running on Acquia dev desktop, it sets a custom path for
  // the dynamic link library. But 2012-04 that was OLDER than the libraries
  // My OS expected to use to run graphics utilities with.
  // Reason: Incompatible library version: dot requires version 10.0.0 or later, but libltdl.7.dylib provides version 9.0.0
  // UNSET the Acquia DYLD_LIBRARY_PATH before dropping to commandline to run.
  $DYLD_LIBRARY_PATH = getenv("DYLD_LIBRARY_PATH");
  putenv("DYLD_LIBRARY_PATH=");

  watchdog('pdf_to_image', 'Running commandline %command', array('%command' => $command), WATCHDOG_DEBUG);

  $response = shell_exec($command);

  // Put it back just in case it matters
  putenv("DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH");

  return $response;
}


/**
 * To enhance filefield_paths, publish the filename of the source document that could be used to create the filepath of the derived document.
 *
 * Implements hook_token_info().
 */
function pdf_to_image_token_info() {
  $info['tokens']['node']['p2i-source-filename'] = array(
    'name' => t("File name"),
    'description' => t("File name of the source PDF without extension."),
  );

  /*
  // Provide tokens for any fields that are used as pdf sources.
  // Do a complex lookup here to avoid having to do it in the token call itself.
  $all_fields = field_info_instances();
  // All entities, all bundles.
  foreach ($all_fields as $entity_type => $entity_fields) {
    foreach ($entity_fields as $bundle_id => $bundle_fields) {
      foreach ($bundle_fields as $field_id => $field) {
        if ($field['widget']['type'] == 'pdf_to_image') {
          $fields_pdf[$field_id] = $field;
          // THIS is a field I need to provide a token from
          // TODO - I really should index by field ID so the token generator
          // knows what to look for without analyzing the content type each time.
          // $info['tokens'][$entity_type][$field_id . ':p2i-filename'] = array(
          // But how...
          $info['tokens'][$entity_type]['p2i-source-filename'] = array(
            'name' => $field['label'],
            'description' => t("File name of the source PDF without extension."),
          );
        }
      }

    }
  }
  // Fail. If I encode the field name into the token, then I can't scan for it
  // later until I know what the field name is. So no win there.
  */
  return $info;
}

/**
 * Fills in a token with the filename of the source pdf field that may be
 * attached to an entity. Not very well-structured here yet.
 *
 * Implements hook_tokens().
 */
function pdf_to_image_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $sanitize = !empty($options['sanitize']);

  $replacements = array();
  if ($type == 'entity' && !empty($data['entity'])) {
    $entity = $data['entity'];
    // Find any fields on this entity that may be source files for a PDF conversion.
    if ($data['entity_type'] == 'node') {
      $bundle = $entity->type;
    }
    else {
      // Dunno how to get bundle from other entities?
      // TOD) - find the API for this.
      return;
    }

    $fields = field_info_instances($data['entity_type'], $bundle);
    $fields_pdf = array();
    foreach ((array) $fields as $field_id => $field) {
      if ($field['widget']['type'] == 'pdf_to_image') {
        $fields_pdf[$field_id] = $field;

        if (isset($entity->{$field_id})) {
          $source_field_values = $entity->{$field_id};
          $field_lang = field_language($data['entity_type'], $entity, $field_id);
          $source_values = $source_field_values[$field_lang];
          // Assumed to be multiple
          foreach ($source_values as $delta => $file_info) {
            // fall-through. We've found it now.
          }
        }

      }
    }

    // This looks like a slow way to do things, no?
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'p2i-source-filename':
          $info = pathinfo($file_info['filename']);
          $replacements[$original] = $info['filename'];
          break;
      }
    }
  }

  return $replacements;
}
