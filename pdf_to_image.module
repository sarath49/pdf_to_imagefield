<?php

/**
 * @file
 *   Extends file fileds with a process that generates a thumbnail image
 *   or multiple image pages from an uploaded PDF
 */

/**
 * Announces that we have additional widget options that extend file fields.
 *
 * @see file_field_widget_info()
 *
 * Implements hook_field_widget_info().
 */
function pdf_to_image_field_widget_info() {
  return array(
    'pdf_to_image' => array(
      'label'       => t('PDF to Image'),
      'field types' => array('file'),
      'settings'    => array(
        'pdf_to_image' => array(
          'target_field'        => NULL,
          'density'             => '100x100',
          'extra_args'          => '',
        ),
      ),
      'behaviors'   => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_NONE,
      ),
    ),
  );
}


#function pdf_to_image_form_alter($form, $form_state, $form_id) {
#  dpm(get_defined_vars());
#}

/**
 * Tell field API that we want it to save some extra settings.
 *
 * remove - data is in the widget settings
 */
function xxpdf_to_image_field_info_alter(&$info) {
  dpm(__FUNCTION__);
  if (isset($info['file'])) {
    $info['file']['settings'] += array(
      'target_field' => NULL,
      'density' => '100x100',
      'extra_args' => '',
      'hide_imagefield' => FALSE,
    );
  }
}


/**
 * Adds extra options to file upload widget when the field is editable
 *
 * Implements hook_field_widget_form().
 */
function pdf_to_image_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  dpm(__FUNCTION__);

  // This is a file widget, plus extra options.
  $elements = file_field_widget_form($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);
  $settings = $instance['settings'];

  foreach (element_children($elements) as $delta) {
    // If not using custom extension validation, ensure this is a pdf.
    $elements[$delta]['#upload_validators']['file_validate_extensions'][0] = 'pdf';
    // File fields need extra processing. Our one even more so.
    #$elements[$delta]['#process'][] = 'pdf_to_image_field_widget_process';
  }
  $elements[0]['#description'] .= '<br/>' . t('This file will produce an image thumbnail and store it in %target_field when uploaded', array('%target_field' => $instance['widget']['settings']['pdf_to_image']['target_field']));

  // When a file field is being submitted, the actual save of the file happens
  // in file_managed_file_value -> file_managed_file_save_upload
  // We rely on file_managed_file_submit , file_field_widget_submit, to have run.
  // We want to add a process that happens after that.
  // That's too deep.
  // run our process as part of the form submit. This shoul mean the element upload has already finished.
  #dpm($form);
  $form['#submit'][] = 'pdf_to_image_form_submit';
  // Need to make a note on the form of what it is to process, as it will forget otherwise
  $form['#pdf_to_image'][] = $instance['field_name'];
  // pdf_to_image_form_submit will pick this note up

  return $elements;
}


/**
 * Adds options to the field configuratin form in the content type admin setup.
 *
 * Implements hook_field_widget_settings_form().
 */
function pdf_to_image_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $pdf_to_image_settings = $widget['settings']['pdf_to_image'];

  // Use the file widget settings form.
  $form = file_field_widget_settings_form($field, $instance);

  // Plus our own extras
  $form['pdf_to_image'] = array(
    '#type' => 'fieldset',
    '#title' => t('PDF conversion options'),
  );

  $fields = field_info_instances($instance['entity_type'], $instance['bundle']);
  $options = array();
  foreach ((array) $fields as $field) {
    if ($field['widget']['type'] == 'image_image') {
      $options[$field['field_name']] = $field['label'];
    }
  }

  // @TODO: make this field required.
  $form['pdf_to_image']['target_field'] = array(
    '#title'         => t('Target Image Field'),
    '#type'          => 'select',
    '#empty_option'  => '<' . (count($options) ? t('No Image Field selected') : t('No Image Field found')) . '>',
    '#default_value' => $pdf_to_image_settings['target_field'],
    '#description'   => t('PDF to Image field processing requires an image field where the resulting images of extracted PDF pages should be stored. The image field must be assigned to the same node type. For all pages to be processed, the image field should allow multiple uploads. If the image field allows only one item, only the cover page will be processed.'),
    '#options'       => $options,
  );

  $form['pdf_to_image']['density'] = array(
    '#title'            => t('Density used for rendering PDF'),
    '#description'      => t('Horizontal and vertical density of the image XxY (e.g. 120x120). Default is 100x100.'),
    '#type'             => 'textfield',
    '#default_value'    => $pdf_to_image_settings['density'],
    '#element_validate' => array('pdf_to_image_validate_density'),
    '#size'             => 15,
    '#maxlength'        => 10,
  );

  $form['pdf_to_image']['extra_args'] = array(
    '#title'         => t('Extra conversion arguments'),
    '#type'          => 'textfield',
    '#description'   => t('Enter optional <a href="http://imagemagick.org/Usage/formats/#ps">additional parameters to be used by the imagemagick conversion</a> if needed.<br/>eg <code>-trim +repage</code>'),
    '#default_value' => !empty($pdf_to_image_settings['extra_args']) ? $pdf_to_image_settings['extra_args'] : '',
    '#size'          => 20,
  );

  // @TODO: implement this.
  $form['pdf_to_image']['extra_args']['#description'] .= '<br />' . t('WARNING! not working feature now.');

  $form['pdf_to_image']['hide_imagefield'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Hide target image field on edit form'),
    '#default_value' => !empty($pdf_to_image_settings['hide_imagefield']),
    '#description'   => t('If rendering the preview image in place of the uploaded file, you may want to hide the image field from the edit form entirely to prevent editors from adding their own.'),
  );

  // @TODO: add radiobuttons to choose way of pages generating,
  // means batch (be default now) or queue or runtime,
  // and implements this ways.
  return $form;
}


/**
 * Validate string for density settings.
 */
function pdf_to_image_validate_density($element, &$form_state) {
  $value = $element['#value'];
  if (!empty($value) && !preg_match('/^[0-9]+x[0-9]+$/', $value)) {
    form_set_error('density', t('Please specify a density in the format XxY (e.g. 120x120).'));
  }
}



/**
 * Adds another method for displaying PDF files - embedded live preview.
 *
 * Implements hook_field_formatter_info().
 */
function pdf_to_image_field_formatter_info() {
  $formatters = array(
    'pdf_view' => array(
      'label'       => t('PDF preview'),
      'field types' => array('file'),
      'settings'    => array(
        'pdf_width'  => '100%',
        'pdf_height' => '450',
      ),
    ),
  );
  return $formatters;
}


/**
 * Implements hook_field_formatter_settings_summary().
 */
function pdf_to_image_field_formatter_settings_summary($field, $instance, $view_mode) {
  dpm(__FUNCTION__);
  $display  = $instance['display'][$view_mode];
  $settings = $display['settings'];
  if ($display['type'] == 'pdf_view') {
    $summary  = t('Region of @width to @height, and text at download link - "@alt"', array(
      '@width'  => $settings['pdf_width'],
      '@height' => $settings['pdf_height'],
      '@alt'    => $settings['pdf_alt'],
    ));
    return $summary;
  }
}


/**
 * Implements hook_field_formatter_view().
 */
function pdf_to_image_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  dpm(__FUNCTION__);
  if (!isset($items[0])) {
    return;
  }

  // @TOFO fix public / private handlers, apply stream wrappers functions.
  global $base_url;
  $path     = $base_url . '/' . variable_get('file_public_path') . substr($items[0]['uri'], 8);

  if ($display['type'] == 'pdf_view') {
    $width    = $display['settings']['pdf_width'];
    $height   = $display['settings']['pdf_height'];
    $alt      = $display['settings']['pdf_alt'];
    $object   = '<object width="' . $width . '" height="' . $height . '" type="application/pdf" data="' . $path . '"><a href="' . $path . '">' . $alt . '</a></object>';
  }

  if ($display['type'] == 'pdf_link') {
    // @TODO add title support.
    $object = l(t('Download file'), $path);
  }

  $element  = array();
  $element[0]['#markup'] = $object;

  return $element;
}


/**
 * Implements hook_form_alter().
 *
 * Hides the target image field from editors, if you don't want them to provide
 * their own snapshot.
 *
 * Should be able to run on any fielded entity type edit form, not just nodes.
 */
function pdf_to_image_form_alter(&$form, &$form_state, $form_id) {
  if (!isset($form['#entity_type']) || !isset($form['#bundle'])) {
    return;
  }

  // Find if this entity has any fields that use the pdf_to_image widget.
  $fields = field_info_instances($form['#entity_type'], $form['#bundle']);
  $fields_pdf = array();
  foreach ((array) $fields as $field) {
    if ($field['widget']['type'] == 'pdf_to_image') {
      $fields_pdf[$field['field_name']] = $field;
    }
  }
  if (count($fields_pdf)) {
    foreach ($fields_pdf as $field) {
      if ($field['widget']['settings']['pdf_to_image']['hide_imagefield']) {
        $target_field = $field['widget']['settings']['pdf_to_image']['target_field'];
        if (isset($form[$target_field])) {
          $form[$target_field]['#access'] = FALSE;
        }
      }
    }
  }
}



/**
 * A field widget process callback, triggered when a form containing our widget type
 * of file is geting rendered.
 *
 * @see file_field_widget_process.
 */
function pdf_to_image_field_widget_process($element, &$form_state, $form) {
  /*
  $item = $element['#value'];
  $item['fid'] = $element['fid']['#value'];

  $field = field_widget_field($element, $form_state);
  $instance = field_widget_instance($element, $form_state);
  $settings = $instance['widget']['settings'];

  dpm('could show a thumbnail here');
  */
  return $element;
}


/**
 * Process our extra actions when a form containing a special file field has
 * been submitted.
 * This is the first step where generation really starts happening.
 *
 * @param array $form
 * @param array $form_state
 */
function pdf_to_image_form_submit($form, &$form_state) {
  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  // The field widget should have made a note of the field we need to process
  // in the custom $form['#pdf_to_image'] parameter.
  foreach ($form['#pdf_to_image'] as $field_id) {
    $field = field_info_field($field_id);
    $instance = field_info_instance($entity_type, $field_id, $bundle);
    $items = $form_state['values'][$field_id];
    $langcode = $form_state['values']['language'];
    pdf_to_image_generate_process($entity_type, $form['#entity'], $field_id, $instance, $langcode, $items);
  }
}

/**
 * Processing pdf file creation.
 *
 * This sets up the batch job with all the neccessary parameters
 */
function pdf_to_image_generate_process($entity_type, $entity, $field, $instance, $langcode, &$items) {
  dpm(__FUNCTION__);
  if (empty($items[$langcode][0]['fid'])) {
    return;
  }
  $pdf_file = file_load($items[$langcode][0]['fid']);
  $pdf_realpath = file_stream_wrapper_get_instance_by_uri($pdf_file->uri)->realpath();
  $count = pdf_to_image_count_pages($pdf_realpath);
  if (!empty($instance['widget']['settings']['pdf_to_image']['target_field'])) {
    $target_field = $instance['widget']['settings']['pdf_to_image']['target_field'];
  }
  if ($target_field && $count) {
    $params = array(
      'entity' => $entity,
      'image'  => array(
        'field'    => field_info_field($target_field),
        'instance' => field_info_instance($entity_type, $target_field, $instance['bundle']),
      ),
      'pdf'    => array(
        'field'    => $field,
        'instance' => $instance,
        'file'     => $pdf_file,
      ),
    );

    // Prepare count parametr.
    if ($params['image']['field']['cardinality'] != -1 && $count > $params['image']['field']['cardinality']) {
      $count = $params['image']['field']['cardinality'];
    }
    $operations = array(
      array('pdf_to_image_generate_process_page', array($params, 0)),
    );

    if ($count > 0) {
      watchdog('pdf_to_image', 'Starting a process to convert attached PDF %file to image previews', array('%file' => $params['pdf']['file']->uri), WATCHDOG_INFO);
      for ($page = 1; $page < $count; $page++) {
        $operations[] = array('pdf_to_image_generate_process_page', array($params, $page));
      }
      batch_set(array(
        'title'            => t('Converting PDF, %count pages', array('%count' => $count)),
        'operations'       => $operations,
        'finished'         => 'pdf_to_image_generate_process_attach',
        'progress_message' => t('Processed @current out of @total.'),
      ));
    }
    // @TODO: save node with one entity without batch.
    // else {
    // $file = pdf_to_image_generate_page($params, 0);
    // }
  }
  else {
    // No target image field set, or invalid count from the PDF.
  }
}


/**
 * Generate a single page in batch process.
 */
function pdf_to_image_generate_process_page($params, $page_number, &$context) {
  $context['results']['params'] = $params;
  if (!isset($context['results']['files'])) {
    $context['results']['files'] = array();
  }
  $file = pdf_to_image_generate_page($params, $page_number);
  if (is_object($file) && isset($file->fid)) {
    $context['results']['files'][$page_number] = $file;
  }
}


/**
 * Attach generated files to node at the end of batch mode.
 */
function pdf_to_image_generate_process_attach($success, $results, $operations) {
  if (!(isset($results['files']) && count($results['files']))) {
    watchdog('pdf_to_image', 'No files produced from processing document', array(), WATCHDOG_NOTICE);
    return;
  }

  $field_name = $results['params']['image']['field']['field_name'];
  $nid = $results['params']['entity']->nid;

  if (isset($nid) && is_numeric($nid)) {
    $node = node_load($nid);
    if (is_object($node)) {
      $field_lang = field_language('node', $node, $field_name);
      $node->{$field_name}[$field_lang] = array();
      ksort($results['files'], SORT_NUMERIC);
      foreach ($results['files'] as $file) {
        $node->{$field_name}[$field_lang][]['fid'] = $file->fid;
      }
      node_save($node);
    }
    else {
      watchdog('pdf_to_image', 'Invalid node object. Cannot attache generated images to it.', array(), WATCHDOG_ERROR);
    }
  }
  else {
    watchdog('pdf_to_image', 'Invalid node id given to attach generated images to.', array(), WATCHDOG_ERROR);
  }
}


/**
 * Generate a single page for the given pdf file.
 */
function pdf_to_image_generate_page($params, $page_number = 0) {
  $source_file = file_stream_wrapper_get_instance_by_uri($params['pdf']['file']->uri)->realpath();
  if (!file_exists($source_file)) {
    watchdog('pdf_to_image', 'Invalid file given to convert. Could not read %file', array('%file' => $params['pdf']['file']->uri), WATCHDOG_ERROR);
    return NULL;
  }

  $density = "-density " . $params['pdf']['instance']['widget']['settings']['pdf_to_image']['density'];

  $image_dir = file_stream_wrapper_get_instance_by_scheme($params['image']['field']['settings']['uri_scheme'])->realpath();
  $image_filename = $params['image']['instance']['settings']['file_directory'] . '/' . $params['pdf']['file']->fid . "-" . $page_number . '.jpg';
  $image_realpath = $image_dir . '/' . $image_filename;
  $image_uri = file_stream_wrapper_uri_normalize($params['image']['field']['settings']['uri_scheme'] . '://' . $image_filename);

  watchdog('pdf_to_image', 'Converting PDF: %file page %page_number: to image: %image', array(
      '%file' => $params['pdf']['file']->uri,
      '%page_number' => $page_number,
      '%image' => $image_uri,
    ), WATCHDOG_INFO
  );

  if (empty($image_uri)) {
    watchdog('pdf_to_image', 'Failed to calculate a destination filename for conversion', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  // Check to see if the target image file already exists, is registered in the
  // database. Why?
  $query = db_select('file_managed', 'f')
    ->fields('f', array('fid'))
    ->condition('uri', $image_uri)
    ->execute()->fetchCol();
  if (!empty($query)) {
    $file = file_load(array_shift($query));
    return $file;
  }

  pdf_to_image_convert_exec($source_file . '[' . $page_number . ']', $image_realpath, array(), array($density));

  if (file_exists($image_realpath)) {
    watchdog('pdf_to_image', 'PDF preview %image created', array(
        '%image' => $image_uri,
      ), WATCHDOG_INFO
    );

    global $user;
    $file = (object) array(
      'uid'       => $user->uid,
      'filename'  => basename($image_uri),
      'uri'       => $image_uri,
      'filemime'  => file_get_mimetype($image_uri),
      'filesize'  => @filesize($image_uri),
      'timestamp' => REQUEST_TIME,
      'status'    => FALSE,
      'is_new'    => TRUE,
    );
    file_save($file);
    return $file;
  }
  watchdog('pdf_to_image', 'Failed to generate image', array(), WATCHDOG_ERROR);
  return FALSE;
}


/**
 * Use imagemagick routine to count the number of pages in a given PDF
 */
function pdf_to_image_count_pages($filepath) {
  $convert_path  = variable_get('imagemagick_convert', '/usr/bin/convert');
  $identify_path = dirname($convert_path) . '/identify';

  // Identify renders every page in the pdf to count the number of pages which
  // can be a problem (server timeout) when processing a pdf with many pages.
  // The better command commented because it working very slow.
  // "{$identify_path} -format %n " . escapeshellarg($fpath) . ' 2> /dev/null';
  $command = "{$identify_path} " . escapeshellarg($filepath) . '[9999] | grep "Requested FirstPage" | cut -d : -f2';

  $count = pdf_to_image_shell_exec($command);
  return (int) trim($count);
}

/**
 * Check the binary path on the server.
 */
function pdf_to_image_check_imagemagick() {
  $convert_path  = variable_get('imagemagick_convert', '/usr/bin/convert');
  $response = pdf_to_image_shell_exec($convert_path . ' -version');
  return $response;
}


/**
 * FWIW, may not need imagemagick module, just for this one func.
 * If you want debugging and Win32 support, use imagemagick.module.
 * Otherwise, here's a short and dirty version of the same thing.
 *
 */
function pdf_to_image_convert_exec($source, $dest, $args = array(), $extra = array()) {
  $args['quality'] = '-quality ' . escapeshellarg(variable_get('imagemagick_quality', 75));
  $command = implode(' ', $extra) . ' ' . escapeshellarg($source) . ' ' . implode(' ', $args) . ' ' . escapeshellarg($dest);

  if (function_exists('_imagemagick_convert_exec')) {
    if (_imagemagick_convert_exec($command, $output, $errors) !== TRUE) {
      $errors_txt = '<pre>' . (is_array($errors) ? implode("\n", $errors) : $errors) . '</pre>';
      watchdog('pdf to image : imageapi imagemagick', $errors_txt, array(), WATCHDOG_ERROR);
      return FALSE;
    }
    return file_exists($dest);
  }

  // else do it myself

  $convert_path  = variable_get('imagemagick_convert', '/usr/bin/convert');
  $response = pdf_to_image_shell_exec($convert_path . ' ' . $command);
  return file_exists($dest);
}

/**
 * Run the given command (expected to be an imageMagick Commandline)
 * Wrapped in a bugfix workaround.
 *
 * @param unknown_type $command
 */
function pdf_to_image_shell_exec($command) {
  // Horrible bug. If running on Acquia dev desktop, it sets a custom path for
  // the dynamic link library. But 2012-04 that was OLDER than the libraries
  // My OS expected to use to run graphics utilities with.
  // Reason: Incompatible library version: dot requires version 10.0.0 or later, but libltdl.7.dylib provides version 9.0.0
  // UNSET the Acquia DYLD_LIBRARY_PATH before dropping to commandline to run.
  $DYLD_LIBRARY_PATH = getenv("DYLD_LIBRARY_PATH");
  putenv("DYLD_LIBRARY_PATH=");

  dpm($command);
  watchdog('pdf_to_image', 'Running commandline %command', array('%command' => $command), WATCHDOG_DEBUG);

  $response = shell_exec($command);

  // Put it back just in case it matters
  putenv("DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH");

  return $response;
}
