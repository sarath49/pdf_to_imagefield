<?php
// $Id$

/**
 * @file
 * PDF to ImageField core hooks and menu callbacks.
 * 
 * CCK widget settings are in an additional library file.
 */

/**
 * Implementation of hook_menu().
 */
function pdf_to_imagefield_menu() {
  $items = array();
  $items['admin/settings/pdf_to_imagefield'] = array(
    'title' => 'PDF to ImageField',
    'description' => 'Allow users to configure pdf conversion settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pdf_to_imagefield_settings_form'),
    'access arguments' => array('administer site configuration'),
    'weight' => 1,
  );
  return $items;
}

/**
 * Implementation of hook_theme().
 */
function pdf_to_imagefield_theme() {
  return array(
    // pdf_to_imagefield_widget form element type theme function.
    'pdf_to_imagefield_widget' => array(
      'arguments' => array('element' => NULL),
    ),
    // Use to generate a preview (admin view) of an imagefield item for use in
    // field item forms and filefield widgets. Invoked by filefield_widget_process.
    'pdf_to_imagefield_widget_preview' => array(
      'arguments' => array('item' => NULL),
    )
  );
}

/**
 * Implementation of hook_cron().
 * 
 * Check th ejob queue for recently added pdfs. Process them and attach the
 * results to the node.
 * 
 * @ingroup cronmethod
 */
function pdf_to_imagefield_cron() {
  $result = db_query_range('SELECT * FROM {pdf_to_imagefield} WHERE finished = 0', variable_get('pdf_to_imagefield_convert_pdf', 1), 0, 1);
  while ($job = db_fetch_object($result)) {
    $pdf_file = field_file_load($job->fid);
    watchdog('pdf_to_imagefield', 'Processing cron queued jobs. !vars', array('!vars' => print_r(get_defined_vars(), 1)));
    if (is_readable($pdf_file['filepath'])) {
      foreach (filefield_get_field_list(NULL, $job->field) as $fieldname => $field) {
        $images = pdf_to_imagefield_convert_pages($job, pdf_to_imagefield_widget_file_path($field), $pdf_file);
        pdf_to_imagefield_save_converted($images, $field, $pdf_file);
        db_query('UPDATE {pdf_to_imagefield} SET finished = %d WHERE fid = %d', time(), $job->fid);
      }
    }
    else {
      // Something's broken, file unavailable. Throw away this job.
      watchdog('pdf_to_imagefield', 'Invalid job queued. PDF file was unavailable. Discarding the job', array(), WATCHDOG_WARNING);
      db_query('DELETE FROM {pdf_to_imagefield} WHERE pid = %d',  $job->pid);
    }
  }
}



/**
 * Convert pages from pdf file to individual jpeg files
 * 
 * @param $job job definition object, defining the pdf file fid, the field name,
 * and some processing parameters.
 * 
 * @param $path folder that the files go into.
 * 
 * @return an array of files, already added to the Drupal files table, that can
 * be added to the node.
 */
function pdf_to_imagefield_convert_pages($job, $path, $pdf_file) {
  $source = $pdf_file['filepath'];
  $filepath = $path . '/' . $pdf_file['fid'] . '.jpg';
  $density = '-density '. $job->density_x .'x'. $job->density_y;
  watchdog('pdf_to_imagefield', 'Converting PDF [%source] now.', array('%source' => $source), WATCHDOG_INFO);
  pdf_to_imagefield_convert_pdf($source, $filepath, array(), array($density));

  // Scan for resulting files. 
  $converted = array();
  // Single page pdfs will have been created with just a filename. 
  // Multipage results are numbered.
  if (file_exists($filepath)) {
    $converted[] = pdf_to_imagefield_save_file($filepath);
  }
  $count = 0;
  
  while (file_exists($path .'/'. $pdf_file['fid'] .'-'. $count .'.jpg')) {
    $filepath = $path . '/' . $pdf_file['fid'] . '-' . $count .'.jpg';
    $converted[] = pdf_to_imagefield_save_file($filepath);
    $count++;
  }

  return $converted;
}

/**
 * Save created image to files table.
 * 
 * @param $filepath
 * @return Object describing the new entry.
 */
function pdf_to_imagefield_save_file($filepath) {
  $file = new stdClass();
  $file->filename = basename($filepath);
  $file->filepath = $filepath;
  $file->filemime = file_get_mimetype($filepath);
  $file->filesize = filesize($filepath);
  $file->status = 1;
  $file->timestamp = time();
  $file->uid = 1;
  drupal_write_record('files', $file);
  return $file;
}

/**
 * Save converted images as ImageField files
 */
function pdf_to_imagefield_save_converted($images, $field, $pdf) {
  foreach (filefield_get_file_references($pdf) as $nid => $vid) {
    $node = node_load($nid);
    if (count($images)) {
      foreach ($images as $image) {
        $image->list = FALSE;
        $node->{$field['field_name']}[] = (array) $image;
      }
      node_save($node);
      watchdog('pdf_to_imagefield', '%images preview images generated for %title node from %pdf PDF file.', array('%images' => count($images), '%title' => $node->title,  '%pdf' => $pdf['filename']));
    }
    else {
      watchdog('pdf_to_imagefield', 'No pdf previews generated for %title node from %pdf PDF file. But it is still in cron list.', array('%title' => $node->title,  '%pdf' => $pdf['filename']), WATCHDOG_ERROR);
    }
  }
}


/**
 * Menu callback. Administrator settings
 */
function pdf_to_imagefield_settings_form($form_state) {
  $form = array();
  $form['pdf_to_imagefield_convert_pdf'] = array(
    '#type' => 'textfield',
    '#title' => t('PDF file limit'),
    '#description' => t('Maximum number of pdf files to process per cron run.'),
    '#default_value' => variable_get('pdf_to_imagefield_convert_pdf', 1),
    '#size' => 6
  );
  $form = system_settings_form($form);
  return $form;
}

/**
 * Convert function (depends on ImageAPI module)
 * This is almost a copy of _imageapi_imagemagick_convert() function, with 
 * that addition of $extra argument, used to pass parameters to convert *BEFORE* 
 * source file specification. 
 * Here it is needed to set density before rendering a PDF  
 */
function pdf_to_imagefield_convert_pdf($source, $dest, $args = array(), $extra = array()) {
  $d_arguments['quality'] = '-quality '. escapeshellarg(variable_get('imageapi_imagemagick_quality', 75));
  // To make use of ImageMagick 6's parenthetical command grouping we need to make
  // the $source image the first parameter and $dest the last.
  // See http://www.imagemagick.org/Usage/basics/#cmdline for more info.

  $command = implode(' ', $extra) .' '. escapeshellarg($source) .' '. implode(' ', $args) .' '. escapeshellarg($dest);
  if (0 != _imageapi_imagemagick_convert_exec($command, $output, $errors)) {
    $errors_txt = '<pre>' . (is_array($errors) ? implode("\n", $errors) : $errors) . '</pre>';
    watchdog('pdf to image: imageapi imagemagick', '!errors', array('!errors' => $errors_txt), WATCHDOG_ERROR);
    return FALSE;
  }

  return file_exists($dest);
}


/**
 * Add a given pdf file to the cron queue for later processing.
 * 
 * @param $pdf_file file data, describing the pdf filefield that is to be
 * scanned. The file data is an object, such as gets stored or retrieved in the
 * drupal 'files' table.
 * @param $source_filefield_def a cck filefield definition, including the rest
 * of the custom settings defining what to do with the converted results.
 * 
 * @ingroup cronmethod
 */
function pdf_to_imagefield_queue_file($pdf_file, $source_filefield_def) {
  $pdf_file = (object)$pdf_file;
  $widget = $source_filefield_def['widget'];
  $job = (object)array(
    'fid' => $pdf_file->fid,
    'field' => $widget['target_imagefield'],
    'count' => 0,
    'density_x' => preg_replace('/^([0-9]+)x[0-9]+$/', '\1', $widget['density']),
    'density_y' => preg_replace('/^[0-9]+x([0-9]+)$/', '\1', $widget['density']),
    'finished' => 0,
  );
  drupal_write_record('pdf_to_imagefield', $job);
  watchdog('pdf_to_imagefield', 'Added %file to queue for later cron processing. Images will be generated on the next cron run.', array('%file' => $pdf_file->filepath));
  drupal_set_message(t('Added %file to queue for conversion to images. It should happen soon.', array('%file' => basename($pdf_file->filepath))));
}

/**
 * Prepare the batch job to process a pdf file.
 * 
 */
function pdf_to_imagefield_set_batch($node, $pdf_file, $source_filefield = NULL) {
  $args = array($node->nid, $pdf_file['fid'], $source_filefield);
  $operations[] = array('pdf_to_imagefield_process_pdf', $args);
  batch_set(array(
    'title' => t('Converting PDF'),
    'operations' => $operations,
  ));
  //batch_process();
}


/**
 * Implementation of hook_file_delete().
 *
 * Delete this job from our table
 * 
 * @ingroup cronmethod
 */
function pdf_to_imagefield_file_delete($file) {
  db_query('DELETE FROM {pdf_to_imagefield} WHERE fid = %d', $file->fid);
}


/**
 * Generate a single page for the given pdf file-source, according to the
 * field settings.
 * 
 * @param $node the field is attached to 
 * @param $source filefiled a field definition
 * @return a managed jpeg file, already inserted into the files table.
 */
function pdf_to_imagefield_generate_single_page($pdf_file, $source_filefield_def, $page_number = 0) {
  if (empty($pdf_file['filepath']) || !file_exists($pdf_file['filepath'])) {
    return NULL;
  }
  
  // Security - ensure no nasty characters make it through to the commandline due to configuration passthroughs.
  preg_match('/^([0-9]+)x([0-9]+)$/', $source_filefield_def['widget']['density'], $matches);
  $density = "-density {$matches[1]}x{$matches[2]}";

  $path = pdf_to_imagefield_widget_file_path($source_filefield_def);

  // Adding [n] to the end of the pdf filename generates just the numbered page.
  $source = $pdf_file['filepath'] . "[$page_number]";
  $image_filename = $pdf_file['fid'] .'.jpg';
  $image_filepath = $path .'/'. $image_filename;

  pdf_to_imagefield_convert_pdf($source, $image_filepath, array(), array($density));
  // This will have created a single file named after the file id.

  if (file_exists($image_filepath)) {
    // Insert file into files table
    $image = pdf_to_imagefield_file_placeholder($image_filepath);
    drupal_write_record('files', $image);
    return $image;
  }
  // if no file, something must have failed. Too bad.
}


/**
 * Given an node and a file to process, do so.
 */
function pdf_to_imagefield_process_pdf(&$node, $source_file, $source_filefield_def) {
  // Args may either be the full objects, or just identifiers for those objects : nid,fid, fieldname
  if (is_numeric($node)) {
    $node = node_load($node);
  }
  if (is_numeric($source_file)) {
    $source_file = field_file_load($source_file);
  }
  if (is_string($source_filefield_def)) {
    $source_filefield_def = content_fields($source_filefield_def);
  }
  $widget = $source_filefield_def['widget'];
  $job = (object)array(
    'density_x' => preg_replace('/^([0-9]+)x[0-9]+$/', '\1', $widget['density']),
    'density_y' => preg_replace('/^[0-9]+x([0-9]+)$/', '\1', $widget['density']),
  );
  $images = pdf_to_imagefield_convert_pages($job, pdf_to_imagefield_widget_file_path($source_filefield_def), $source_file);
  pdf_to_imagefield_attach_files($images, $node, $source_filefield_def['widget']['target_imagefield']);
  return count($images);
}


/**
 * hook_nodeapi
 * 
 * When saving a node, see if it's got a PDF that needs converting. Pass
 * processing to individual op handlers, D7-style
 */
function pdf_to_imagefield_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  // First check if this node has one of our widgets active.
  $source_filefield_def = pdf_to_imagefield_source_filefield($node);
  if (!$source_filefield_def) {
    return;
  }

  switch ($op) {
    case 'presave' :
      // operations happen at presave, due to the way filefield handles things 
      return pdf_to_imagefield_node_presave($node);
      break;
  }  // /switch
}

/**
 * hook_node_presave() nodapi subroutine
 * 
 * Check to see if this node has a pdf file that needs processing immediately -
 * or later.
 */
function pdf_to_imagefield_node_presave(&$node) {
  $type = content_types($node->type);
  $source_filefield_def = pdf_to_imagefield_source_filefield($node);
  $source_filefield = $source_filefield_def['field_name'];
  $target_imagefield = $source_filefield_def['widget']['target_imagefield'];
  $target_imagefield_def = $type['fields'][$target_imagefield];

  // Is the source filefield full and the target image holder empty?
  if (!pdf_to_imagefield_empty_filefield($node->{$source_filefield}) && pdf_to_imagefield_empty_filefield($node->{$target_imagefield})) {
    
    // Select the pdf entry(s?) in the specified filefield.
    // Usually just one
    foreach ($node->{$source_filefield} as $pdf_file) {
      if ($target_imagefield_def['multiple']) {
        // Add this job to the queue;
        pdf_to_imagefield_queue_file($pdf_file, $source_filefield_def);
        //pdf_to_imagefield_set_batch($node, $pdf_file, $source_filefield_def);
      }
      else {
        // Multiple is off, so we will only do the cover page.
        // We can do this immediately.
        // Generate the cover page as a managed image file.
        $image_file = pdf_to_imagefield_generate_single_page($pdf_file, $source_filefield_def, 0);
        // And attach to the node
        if ($image_file) {
          $node->{$target_imagefield}[] = (array) $image_file;
        }
      }
      // node_save will do the rest later
    }
  }
  // On the other hand, if the filefield is empty and the images full, 
  // the original has just been deleted. filefield widget does that
  // earlier - to early for me to get in on it.
  if (pdf_to_imagefield_empty_filefield($node->{$source_filefield}) && !pdf_to_imagefield_empty_filefield($node->{$target_imagefield})) {
    watchdog('pdf_to_imagefield', 'Deleting all the image fields previously attached to %title as derivatives of the deleted PDF file.', array('%title' => $node->title), WATCHDOG_NOTICE);
    foreach ($node->{$target_imagefield} as $i => $image_file ) {
      $removed_file = field_file_load($image_file['fid']);
      field_file_delete($image_file);
      unset($node->{$target_imagefield}[$i]);
    }
  }
}

/**
 * Given a node, returns whether that node type has any pdf filefields that this
 * module should operate on.
 * 
 * @param $node The node to be checked
 * @return the field definition of the filefield that holds the pdf and the
 * widget settings.
 */
function pdf_to_imagefield_source_filefield($node) {
  // See if this node has a pdf_to_imagefield field 
  // and it's got content 
  $type = content_types($node->type);
  if (empty($type['fields'])) {
    // No CCK, return immediately
    return NULL;
  }
  // Find any fields of type pdf_to_imagefield. Note the settings
  foreach ($type['fields'] as $field_def) {
    if ($field_def['widget']['module'] == 'pdf_to_imagefield') {
      return $field_def;
    }
  }
  return NULL;
}

/**
 * Utility to check if a nodes field array is really empty.
 * 
 * Dunno  why, but cck keep saving useless placeholders, field is not truly
 * empty, but contains an 'empty' item. 
 * 
 * @return if the array is effectively empty or not
 */
function pdf_to_imagefield_empty_filefield($field_array) {
  foreach ($field_array as $i => $f) {
    if (!empty($f['fid'])) {
      return FALSE;
    }
  }
  return TRUE;
}



/**
 * Attach the list of files to the given node and save it.
 * 
 */
function pdf_to_imagefield_attach_files($images, $node, $field_name) {
  if (count($images)) {
    foreach ($images as $image) {
      $image->list = FALSE;
      $node->{$field_name}[] = (array) $image;
    }
    node_save($node);
    watchdog('pdf_to_imagefield', '%images files attached to %title node.', array('%images' => count($images), '%title' => $node->title));
  }
  else {
    watchdog('pdf_to_imagefield', 'No files attached to %title node.', array('%title' => $node->title), WATCHDOG_ERROR);
  }
}


/** 
 * CCK widget and field settings for our new type of filefield.
 * 
 * We mostly emulate the normal filefield widget, but have added a couple of
 * extra settings.
 */

/**
 * Implementation of hook_elements().
 * 
 * Publishes our custom filefield widget.
 */
function pdf_to_imagefield_elements() {
  $elements = array();
  // An PDF to ImageField is really just a FileField.
  $filefield_elements = module_invoke('filefield', 'elements');
  $elements['pdf_to_imagefield_widget'] = $filefield_elements['filefield_widget'];
  $elements['pdf_to_imagefield_widget']['#process'][] = 'pdf_to_imagefield_widget_process';
  return $elements;
}


/**
 * Implementation of CCK's hook_widget().
 * 
 * Stub to the normal filefield behavior
 */
function pdf_to_imagefield_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  return filefield_widget($form, $form_state, $field, $items, $delta);
}

/**
 * Implementation of CCK's hook_widget_info().
 */
function pdf_to_imagefield_widget_info() {
  $module_path = drupal_get_path('module', 'pdf_to_imagefield');
  return array(
    'pdf_to_imagefield_widget' => array(
      'label' => t('PDF to ImageField'),
      'field types' => array('filefield'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array('default value' => CONTENT_CALLBACK_CUSTOM),
      'description' => t('An edit widget for pdf files, including functionality to convert pdf pages to ImageField files.'),
    ),
  );
}

/**
 * Implementation of CCK's hook_widget_settings().
 */
function pdf_to_imagefield_widget_settings($op, $widget) {
  switch ($op) {
    case 'form':
      return pdf_to_imagefield_widget_settings_form($widget);
    case 'validate':
      return pdf_to_imagefield_widget_settings_validate($widget);
    case 'save':
      return pdf_to_imagefield_widget_settings_save($widget);
  }
}

/**
 * @file
 * PDF to ImageField widget hooks and callbacks.
 */

/**
 * Implementation of CCK's hook_widget_settings($op = 'form').
 */
function pdf_to_imagefield_widget_settings_form($widget) {
  if (!pdf_to_imagefield_check_imagemagick($widget)) {
    drupal_set_message(t('ImageMagick test pdf to image conversion failed. Please check your system ImageMagick and/or Ghostscript configuration. While you seeing this message, pdf files will be queued and stay unprocessed.'), 'error');
  }
  // get standart settings from filefield
  $form = module_invoke('filefield', 'widget_settings', 'form', $widget);
  // set & lock pdf extension from modification
  $form['file_extensions']['#default_value'] = 'pdf';
  $form['file_extensions']['#disabled'] = TRUE;
  // create list of options to target form
  $imagefields = array();
  $filefields = filefield_get_field_list(arg(3));
  foreach ($filefields as $key => $filefield) {
    if ($filefield['widget']['module'] == 'imagefield' && $filefield['multiple'] == 1) {
      $imagefields[$key] = $filefield['widget']['label'] .' ('. $filefield['field_name'] .')';
    }
  }
  // just 4fun
  $imagefields[0] = count($imagefields)
    ? t('No ImageField selected')
    : t('No ImageField found');
  // target form
  $form['target_imagefield'] = array(
    '#type' => 'select',
    '#title' => t('Target ImageField'),
    '#options' => $imagefields,
    '#default_value' => !empty($widget['target_imagefield']) ? $widget['target_imagefield'] : 0,
    '#description' => t('Choose an ImageField where should be stored extracted pages. ImageField must be assigned to the same node type and should allow to upload multiple images.'),
  );

  $form['density'] = array(
    '#type' => 'textfield',
    '#title' => t('Density used for rendering PDF'),
    '#default_value' => !empty($widget['density']) ? $widget['density'] : '100x100',
    '#size' => 15,
    '#maxlength' => 10,
    '#description' => t('Horizontal and vertical density of the image XxY (e.g. 120x120). Default is 100x100.'),
  );
  return $form;
}

/**
 * Implementation of CCK's hook_widget_settings($op = 'validate').
 */
function pdf_to_imagefield_widget_settings_validate($widget) {
  // Check that set density is valid.
  if (!empty($widget['density']) && !preg_match('/^[0-9]+x[0-9]+$/', $widget['density'])) {
    form_set_error('density', t('Please specify a density in the format XxY (e.g. 120x120).'));
  }
}

/**
 * Implementation of CCK's hook_widget_settings($op = 'save').
 */
function pdf_to_imagefield_widget_settings_save($widget) {
  $filefield_settings = module_invoke('filefield', 'widget_settings', 'save', $widget);
  return array_merge($filefield_settings, array('target_imagefield', 'density'));
}


/**
 * Element #process callback function.
 */
function pdf_to_imagefield_widget_process($element, $edit, &$form_state, $form) {
  $file = $element['#value'];
  if (isset($element['preview']) && $file['fid'] != 0) {
    $element['preview']['#value'] = theme('pdf_to_imagefield_widget_preview', $file);
  }
  return $element;
}

/**
 * FormAPI theme function. Theme the output of an pdf field.
 */
function theme_pdf_to_imagefield_widget($element) {
  $element['#id'] .= '-upload'; // Link the label to the upload field.
  return theme('form_element', $element, $element['#children']);
}


/**
 * Widget previews theme
 */
function theme_pdf_to_imagefield_widget_preview($file) {
  // Remove the current description so that we get the filename as the link.
  if (isset($file['data']['description'])) {
    unset($file['data']['description']);
  }
  // get finished date or zero if not
  $finished = db_result(db_query_range('SELECT finished FROM {pdf_to_imagefield} WHERE fid = %d', $file['fid'], 0, 1));
  // define status text
  $status = $finished
    ? t('Page previews generated at %date', array('%date' => format_date($finished, 'custom', 'Y.m.d H:i')))
    : t('Page previews generation not completed. Waiting in queue.');
  // return output
  return '<div class="filefield-file-info">'.
           '<div class="filename">'. theme('filefield_file', $file) .'</div>'.
           '<div class="filesize">'. format_size($file['filesize']) .'</div>'.
           '<div class="filemime">'. $file['filemime'] .'</div>'.
           '<div class="pdfstatus"><small>'. $status .'</small></div>'.
         '</div>';
}

/**
 * Implementation of CCK's hook_default_value().
 * 
 * Stub to the normal filefield behavior
 */
function pdf_to_imagefield_default_value(&$form, &$form_state, $field, $delta) {
  return filefield_default_value($form, $form_state, $field, $delta);
}


/**
 * Helper function to check if ImageMagick is ready to convert
 */
function pdf_to_imagefield_check_imagemagick($widget) {
  // init test varaibles
  $source = drupal_get_path('module', 'pdf_to_imagefield') .'/imagemagick_test.pdf';
  $result = file_directory_path() . '/imagemagick_test.jpg';
  $density = !empty($widget['density']) ? $widget['density'] : '100x100';
  // check conversion
  if (pdf_to_imagefield_convert_pdf($source, $result, array(), array('-density '. $density))) {
    file_delete($result);
    return TRUE;
  }
  return FALSE;
}


/**
 * Check if field path is good to save file
 */
function pdf_to_imagefield_widget_file_path($field) {
  $path = filefield_widget_file_path($field);
  if (!file_check_directory($path, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS, 'default_path')) {
    return FALSE;
  }
  return $path;
}

/**
 * Helper function to check if file is good to convert pages.
 * 
 * Ensures the settings are valid.
 */
function pdf_to_imagefield_check_file($file) {
  // Check if variables are in place.
  if (!isset($file->field['widget']['module']) 
    || $file->field['widget']['module'] != 'pdf_to_imagefield'
    ) {
    watchdog('pdf_to_imagefield', 'Invalid configuration, %pdf file.', array(  '%pdf' => $file['filename']));
    return FALSE;
  }
  if (empty($file->field['widget']['target_imagefield'])) {
    return FALSE;
  }
  // Validate the filepath
  if (empty($file->filepath) || !file_exists($file->filepath)) {
    return FALSE;
  }
  // Return TRUE if otherwise OK.
  return TRUE;
}
